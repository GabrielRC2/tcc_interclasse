/**
 * Utilit√°rios para gerenciar pontua√ß√£o do torneio
 * Separa√ß√£o clara entre pontos da partida (gols) e pontos do torneio (classifica√ß√£o)
 */

// Constantes de pontua√ß√£o do torneio
export const PONTOS_TORNEIO = {
  VENCEDOR: 3,
  EMPATE: 1,
  PERDEDOR: 0,
  WO: 0, // Time que d√° WO n√£o ganha pontos
  PENDENTE: 0
};

/**
 * Calcula os pontos do torneio baseado no resultado
 * @param {string} resultado - VENCEDOR, PERDEDOR, EMPATE, WO, PENDENTE
 * @returns {number} Pontos do torneio (0, 1 ou 3)
 */
export function calcularPontosTorneio(resultado) {
  return PONTOS_TORNEIO[resultado] || 0;
}

/**
 * Determina o resultado baseado nos pontos da partida e p√™naltis
 * @param {number} pontosCasa - Pontos/gols do time da casa
 * @param {number} pontosVisitante - Pontos/gols do time visitante
 * @param {number} penaltisCasa - Gols de p√™nalti do time da casa (opcional)
 * @param {number} penaltisVisitante - Gols de p√™nalti do time visitante (opcional)
 * @param {boolean} temPenaltis - Se a partida foi para os p√™naltis
 * @returns {{resultadoCasa: string, resultadoVisitante: string}}
 */
export function determinarResultado(pontosCasa, pontosVisitante, penaltisCasa = 0, penaltisVisitante = 0, temPenaltis = false) {
  // Se n√£o h√° p√™naltis, usar l√≥gica tradicional
  if (!temPenaltis) {
    if (pontosCasa > pontosVisitante) {
      return {
        resultadoCasa: 'VENCEDOR',
        resultadoVisitante: 'PERDEDOR'
      };
    } else if (pontosVisitante > pontosCasa) {
      return {
        resultadoCasa: 'PERDEDOR',
        resultadoVisitante: 'VENCEDOR'
      };
    } else {
      return {
        resultadoCasa: 'EMPATE',
        resultadoVisitante: 'EMPATE'
      };
    }
  }

  // Se h√° p√™naltis, o vencedor √© definido pelos p√™naltis (n√£o pode haver empate)
  if (penaltisCasa > penaltisVisitante) {
    return {
      resultadoCasa: 'VENCEDOR',
      resultadoVisitante: 'PERDEDOR'
    };
  } else {
    return {
      resultadoCasa: 'PERDEDOR',
      resultadoVisitante: 'VENCEDOR'
    };
  }
}

/**
 * Atualiza a pontua√ß√£o do torneio para uma partida
 * @param {object} prisma - Inst√¢ncia do Prisma
 * @param {number} partidaId - ID da partida
 * @param {number} pontosCasa - Pontos da s√∫mula do time da casa
 * @param {number} pontosVisitante - Pontos da s√∫mula do time visitante
 * @param {number} penaltisCasa - Gols de p√™nalti do time da casa (opcional)
 * @param {number} penaltisVisitante - Gols de p√™nalti do time visitante (opcional)
 * @param {boolean} temPenaltis - Se a partida foi para os p√™naltis
 */
export async function atualizarPontuacaoTorneio(prisma, partidaId, pontosCasa, pontosVisitante, penaltisCasa = 0, penaltisVisitante = 0, temPenaltis = false) {
  // Buscar informa√ß√µes da partida
  const partida = await prisma.partida.findUnique({
    where: { id: partidaId },
    include: {
      times: {
        include: {
          time: true
        }
      }
    }
  });

  if (!partida) {
    throw new Error('Partida n√£o encontrada');
  }

  // Determinar resultados baseados nos pontos e p√™naltis
  const { resultadoCasa, resultadoVisitante } = determinarResultado(
    pontosCasa, 
    pontosVisitante, 
    penaltisCasa, 
    penaltisVisitante, 
    temPenaltis
  );
  
  const timeCasa = partida.times.find(pt => pt.ehCasa);
  const timeVisitante = partida.times.find(pt => !pt.ehCasa);

  if (!timeCasa || !timeVisitante) {
    throw new Error('Times da partida n√£o encontrados');
  }

  // Calcular pontos do torneio
  const pontosTorneioCasa = calcularPontosTorneio(resultadoCasa);
  const pontosTorneioVisitante = calcularPontosTorneio(resultadoVisitante);

  // Atualizar na base de dados
  await Promise.all([
    // Atualizar resultados dos times
    prisma.partidaTime.update({
      where: {
        partidaId_timeId: {
          partidaId: partidaId,
          timeId: timeCasa.timeId
        }
      },
      data: {
        resultado: resultadoCasa,
        pontosTorneio: pontosTorneioCasa
      }
    }),
    prisma.partidaTime.update({
      where: {
        partidaId_timeId: {
          partidaId: partidaId,
          timeId: timeVisitante.timeId
        }
      },
      data: {
        resultado: resultadoVisitante,
        pontosTorneio: pontosTorneioVisitante
      }
    })
  ]);

  return {
    timeCasa: {
      nome: timeCasa.time.nome,
      resultado: resultadoCasa,
      pontosTorneio: pontosTorneioCasa
    },
    timeVisitante: {
      nome: timeVisitante.time.nome,
      resultado: resultadoVisitante,
      pontosTorneio: pontosTorneioVisitante
    }
  };
}

/**
 * Processa WO definindo resultados espec√≠ficos
 * @param {object} prisma - Inst√¢ncia do Prisma
 * @param {number} partidaId - ID da partida
 * @param {number} timeWOId - ID do time que deu WO
 */
export async function processarWO(prisma, partidaId, timeWOId) {
  const partida = await prisma.partida.findUnique({
    where: { id: partidaId },
    include: {
      times: {
        include: {
          time: true
        }
      }
    }
  });

  if (!partida) {
    throw new Error('Partida n√£o encontrada');
  }

  const timeWO = partida.times.find(pt => pt.timeId === timeWOId);
  const timeVencedor = partida.times.find(pt => pt.timeId !== timeWOId);

  if (!timeWO || !timeVencedor) {
    throw new Error('Times da partida n√£o encontrados');
  }

  // Atualizar resultados na partida espec√≠fica
  await Promise.all([
    prisma.partidaTime.update({
      where: {
        partidaId_timeId: {
          partidaId: partidaId,
          timeId: timeWOId
        }
      },
      data: {
        resultado: 'WO', // Manter 'WO' como resultado espec√≠fico
        pontosTorneio: calcularPontosTorneio('WO') // 0 pontos
      }
    }),
    prisma.partidaTime.update({
      where: {
        partidaId_timeId: {
          partidaId: partidaId,
          timeId: timeVencedor.timeId
        }
      },
      data: {
        resultado: 'VENCEDOR',
        pontosTorneio: calcularPontosTorneio('VENCEDOR') // 3 pontos
      }
    })
  ]);

  return {
    timeWO: timeWO.time.nome,
    timeVencedor: timeVencedor.time.nome
  };
}

/**
 * Busca classifica√ß√£o do torneio ordenada por pontos
 * @param {object} prisma - Inst√¢ncia do Prisma
 * @param {number} torneioId - ID do torneio
 * @param {object|number} filtro - Objeto de filtro complexo ou grupoId simples (retrocompatibilidade)
 * @returns {Array} Lista de times com pontua√ß√£o
 */
export async function obterClassificacao(prisma, torneioId, filtro = null) {
  console.log('=== DEBUG CLASSIFICA√á√ÉO ===');
  console.log('TorneioId:', torneioId);
  console.log('Filtro:', filtro);

  let whereClause;

  if (typeof filtro === 'number') {
    // Retrocompatibilidade: filtro simples por grupoId
    whereClause = {
      partida: {
        torneioId: torneioId,
        grupoId: filtro
      }
    };
  } else if (filtro && typeof filtro === 'object') {
    // Novo formato: objeto de filtro completo
    whereClause = filtro;
  } else {
    // Sem filtro: todos os times do torneio
    whereClause = {
      partida: {
        torneioId: torneioId
      }
    };
  }

  console.log('WhereClause:', JSON.stringify(whereClause, null, 2));

  console.log('üîç Buscando classifica√ß√£o com whereClause:', JSON.stringify(whereClause, null, 2));

  const resultados = await prisma.partidaTime.findMany({
    where: whereClause,
    include: {
      time: true,
      partida: true
    }
  });

  console.log(`üìä Encontrados ${resultados.length} registros de partidaTime`);
  
  // Log dos primeiros registros para debug
  if (resultados.length > 0) {
    console.log('üéØ Primeiro registro:', {
      timeId: resultados[0].timeId,
      timeNome: resultados[0].time.nome,
      pontosTorneio: resultados[0].pontosTorneio,
      resultado: resultados[0].resultado,
      partidaId: resultados[0].partidaId
    });
  }

  // Agrupar por time e calcular estat√≠sticas
  const classificacao = resultados.reduce((acc, partidaTime) => {
    const timeId = partidaTime.timeId;
    
    console.log(`üí´ Processando time ${partidaTime.time.nome}:`, {
      pontosTorneio: partidaTime.pontosTorneio,
      resultado: partidaTime.resultado,
      partidaStatus: partidaTime.partida.statusPartida
    });
    
    if (!acc[timeId]) {
      acc[timeId] = {
        timeId,
        nome: partidaTime.time.nome,
        pontos: 0,
        jogos: 0,
        vitorias: 0,
        empates: 0,
        derrotas: 0,
        golsPro: 0,
        golsContra: 0,
        saldoGols: 0,
        temWO: false // Adicionar flag para WO
      };
    }

    const team = acc[timeId];
    
    // S√≥ contar como jogo se a partida foi finalizada
    const partidaFinalizada = partidaTime.partida.statusPartida === 'FINALIZADA';
    
    if (partidaFinalizada) {
      team.pontos += partidaTime.pontosTorneio || 0; // Garantir que n√£o seja null
      team.jogos += 1;

      // Contar resultados
      switch (partidaTime.resultado) {
        case 'VENCEDOR':
          team.vitorias += 1;
          break;
        case 'EMPATE':
          team.empates += 1;
          break;
        case 'PERDEDOR':
          team.derrotas += 1;
          break;
        case 'WO':
          team.derrotas += 1;
          team.temWO = true; // Marcar que o time teve WO
          break;
      }

      // Calcular gols (pontos da partida)
      const partida = partidaTime.partida;
      if (partida.pontosCasa !== null && partida.pontosVisitante !== null) {
        if (partidaTime.ehCasa) {
          team.golsPro += partida.pontosCasa;
          team.golsContra += partida.pontosVisitante;
        } else {
          team.golsPro += partida.pontosVisitante;
          team.golsContra += partida.pontosCasa;
        }
      }

      team.saldoGols = team.golsPro - team.golsContra;
    }

    return acc;
  }, {});

  // Converter para array e ordenar
  const classificacaoArray = Object.values(classificacao).sort((a, b) => {
    // Times com WO sempre v√£o para o final
    if (a.temWO && !b.temWO) return 1;
    if (!a.temWO && b.temWO) return -1;
    
    // Se ambos t√™m WO ou ambos n√£o t√™m, ordenar normalmente
    // Ordenar por: pontos desc, saldo de gols desc, gols pr√≥ desc
    if (b.pontos !== a.pontos) return b.pontos - a.pontos;
    if (b.saldoGols !== a.saldoGols) return b.saldoGols - a.saldoGols;
    return b.golsPro - a.golsPro;
  });

  console.log('üèÜ Classifica√ß√£o final:', classificacaoArray.map(t => ({
    nome: t.nome,
    pontos: t.pontos,
    vitorias: t.vitorias,
    empates: t.empates,
    derrotas: t.derrotas
  })));

  return classificacaoArray;
}
